package main

import (
	"bytes"
	"encoding/json"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
)

type (
	Track struct {
		Title  string   `json:"title"`
		Path   string   `json:"path"`
		Tags   []string `json:"tags"`
		Source string   `json:"source"`
		ID     int      `json:"id"`
	}

	Tracks []*Track

	YoutubeInfo struct {
		Title string `json:"title"`
		URL   string `json:"url"`
		Date  string `json:"date"`
	}

	Contents struct {
		Comment string `json:"comment"`
		Root    string `json:"soundRoot"`
		// MEMO: 他ファイルで定義されたJSONデータを読み込んで、セットする
		Archive interface{} `json:"archiveInfo"`
		Tracks  Tracks      `json:"tracks"`
	}
)

// Len is the number of elements in the collection.
func (t Tracks) Len() int {
	return len(t)
}

// Less reports whether the element with
// index i should sort before the element with index j.
func (t Tracks) Less(i int, j int) bool {
	return t[i].Tags[0] < t[j].Tags[0]
}

// Swap swaps the elements with indexes i and j.
func (t Tracks) Swap(i int, j int) {
	tmp := *t[i]
	tmp.ID = t[j].ID
	t[j].ID = t[i].ID
	t[i] = t[j]
	t[j] = &tmp
}

const (
	rootDir     = "voices/"
	archiveJSON = "archive.json"
	outJSON     = "target/contents.json"
)

func main() {
	if err := run(); err != nil {
		log.Println(err.Error())
		os.Exit(1)
	}
	os.Exit(0)
}

func run() error {

	// 音声データ情報の取得
	trackFilePaths, err := getTrackJSONFilePaths()
	if err != nil {
		return err
	}

	cnt := 0
	var tracks Tracks
	for _, filepath := range trackFilePaths {
		track, err := readTrackJSONData(filepath)
		if err != nil {
			return err
		}
		cnt++
		track.ID = cnt
		tracks = append(tracks, track)
	}

	sort.Sort(tracks)

	// アーカイブ情報の取得
	archiveInfo, err := readArchiveInfoJSONData(archiveJSON)
	if err != nil {
		return err
	}

	// 出力jsonデータ
	contents := Contents{
		Comment: "Code generated file. DO NOT EDIT.",
		Root:    rootDir,
		Archive: archiveInfo,
		Tracks:  tracks,
	}

	buf, err := json.Marshal(contents)
	if err != nil {
		return err
	}

	jsonData := bytes.NewBuffer([]byte{})
	json.Indent(jsonData, buf, "", "  ")

	f, err := os.Create(outJSON)
	if err != nil {
		return err
	}
	defer f.Close()
	if _, err := io.Copy(f, jsonData); err != nil {
		return err
	}
	return nil
}

// カレントディレクトリの voices 以下のjsonファイル一覧を返却する
func getTrackJSONFilePaths() ([]string, error) {
	cd, err := os.Getwd()
	if err != nil {
		return nil, err
	}
	return filepath.Glob(filepath.Join(cd, rootDir, "*.json"))
}

func readTrackJSONData(path string) (*Track, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	buf, err := ioutil.ReadAll(f)
	if err != nil {
		return nil, err
	}

	track := new(Track)
	if err := json.Unmarshal(buf, track); err != nil {
		return nil, err
	}

	return track, nil
}

func readArchiveInfoJSONData(path string) (archiveInfo interface{}, err error) {
	arcFile, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer arcFile.Close()

	buf, err := ioutil.ReadAll(arcFile)
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal(buf, &archiveInfo); err != nil {
		return nil, err
	}
	return archiveInfo, nil
}
